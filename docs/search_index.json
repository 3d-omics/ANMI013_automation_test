[["index.html", "3D’omics | Microsample size experiment Developmental work Chapter 1 Introduction 1.1 Prepare the R environment", " 3D’omics | Microsample size experiment Developmental work Antton Alberdi1 2024-08-09 Chapter 1 Introduction This webbook contains all the code used for the study on the effect of probiotics on Salmonella infection in broiler chicken. 1.1 Prepare the R environment 1.1.1 Environment To reproduce all the analyses locally, clone this repository in your computer using: RStudio &gt; New Project &gt; Version Control &gt; Git And indicating the following git repository: https://github.com/3d-omics/ANMI013_automation_test.git Once the R project has been created, follow the instructions and code chunks shown in this webbook. 1.1.2 Libraries The following R packages are required for the data analysis. # Base library(R.utils) library(knitr) library(tidyverse) library(devtools) library(tinytable) library(broom) library(broom.mixed) library(rairtable) library(jsonlite) # For tree handling library(ape) library(phyloseq) library(phytools) # For plotting library(ggplot2) library(ggrepel) library(ggpubr) library(ggnewscale) library(gridExtra) library(ggtreeExtra) library(ggtree) library(ggh4x) library(jpeg) library(patchwork) # For statistics library(spaa) library(vegan) library(Rtsne) library(geiger) library(hilldiv2) library(distillR) library(ANCOMBC) library(lme4) library(Hmsc) University of Copenhagen, antton.alberdi@sund.ku.dk↩︎ "],["data-preparation.html", "Chapter 2 Data preparation 2.1 Count data 2.2 Filter and normalise data 2.3 Color scheme 2.4 Wrap working objects", " Chapter 2 Data preparation 2.0.1 Sample metadata sample_metadata &lt;- airtable(&quot;4-MSE-Info&quot;, &quot;appKakM1bnKSekwuW&quot;) %&gt;% #get base ID from Airtable browser URL read_airtable(., fields = c(&quot;ID&quot;,&quot;LabBatch_text&quot;,&quot;IntestinalSection&quot;,&quot;SampleType&quot;,&quot;Xcoord&quot;,&quot;Ycoord&quot;,&quot;size&quot;,&quot;cryosection_text&quot;,&quot;buffer_text&quot;,&quot;Collection_Success&quot;,&quot;UsedCycles&quot;), id_to_col = TRUE) %&gt;% #get 3 columns from MAGs table filter(LabBatch_text %in% c(&quot;MSEB0015&quot;)) %&gt;% rename(batch=LabBatch_text,microsample=ID,section=IntestinalSection,type=SampleType,cryosection=cryosection_text,buffer=buffer_text,collection=Collection_Success,cycles=UsedCycles) %&gt;% select(microsample,section,type,batch,cryosection,buffer,Xcoord,Ycoord,size,collection,cycles) %&gt;% unnest(c(section, Xcoord, Ycoord, size, collection, cycles)) %&gt;% arrange(microsample) 2.1 Count data read_counts &lt;- read_tsv(&quot;data/MSEB0015_read_counts.tsv&quot;) %&gt;% rename(genome = 1) %&gt;% pivot_longer(!genome, names_to = &quot;data&quot;, values_to=&quot;counts&quot;) %&gt;% mutate(sample = substr(data, 1, 7)) %&gt;% group_by(genome,sample) %&gt;% summarise(counts=sum(counts), .groups=&quot;drop&quot;) %&gt;% pivot_wider(names_from=&quot;sample&quot;, values_from=&quot;counts&quot;) 2.1.1 Base hit table This is the document containing the number of nucleotide bases have been covered by at least one read in each sample and MAG. This information is used to calculate MAG coverage values. basehits &lt;- read_tsv(&quot;data/MSEB0015_covered_bases.tsv&quot;) %&gt;% rename(genome = 1) %&gt;% pivot_longer(!genome, names_to = &quot;data&quot;, values_to=&quot;counts&quot;) %&gt;% mutate(sample = substr(data, 1, 7)) %&gt;% group_by(genome,sample) %&gt;% summarise(counts=sum(counts), .groups=&quot;drop&quot;) %&gt;% pivot_wider(names_from=&quot;sample&quot;, values_from=&quot;counts&quot;) 2.1.2 Genome metadata Relevant metadata of genomes is fetched from 2-3 files and merged into one genome metadata object for downstream analyses. 2.1.2.1 Taxonomy This is the raw taxonomy table generated by GTDBtk, which is simplified for downstream analyses. genome_taxonomy &lt;- read_tsv(&quot;data/genome_taxonomy.tsv&quot;) %&gt;% rename(genome = user_genome) %&gt;% mutate(genome = str_replace_all(genome,&quot;\\\\.fa&quot;, &quot;&quot;)) %&gt;% separate(classification, c(&quot;domain&quot;,&quot;phylum&quot;,&quot;class&quot;,&quot;order&quot;,&quot;family&quot;,&quot;genus&quot;,&quot;species&quot;), sep =&quot;;&quot;) %&gt;% select(genome,domain,phylum,class,order,family,genus,species) %&gt;% arrange(match(genome, read_counts$genome)) 2.1.2.2 Genome quality Quality properties of the genomes. genome_quality &lt;- read_tsv(&quot;data/genome_quality.tsv&quot;) %&gt;% rename(genome = 1) %&gt;% mutate(genome = str_replace_all(genome,&quot;\\\\.fa&quot;, &quot;&quot;)) %&gt;% arrange(match(genome, read_counts$genome)) %&gt;% select(genome, Completeness, Contamination, Coding_Density, Genome_Size) %&gt;% rename(completeness=Completeness,contamination=Contamination,coding_density=Coding_Density,length=Genome_Size) 2.1.2.3 Merged metadata object Merge taxonomy, length and quality information genome_metadata &lt;- genome_taxonomy %&gt;% left_join(genome_quality,by=join_by(genome==genome)) #join quality 2.1.3 Genome tree This is the raw tree generated by GTDBtk, which needs to be pruned to obtain the phylogenetic tree of the genomes. Note that the archaeal tree is only generated if any archaeans are detected among the genomes. genome_tree &lt;- read.tree(&quot;data/genome_tree.tre&quot;) genome_tree$tip.label &lt;- str_replace_all(genome_tree$tip.label,&quot;&#39;&quot;, &quot;&quot;) #remove single quotes in MAG names genome_tree &lt;- keep.tip(genome_tree, tip=read_counts$genome) # keep only MAG tips 2.1.4 MAG functional annotations This is the raw annotation table generated by DRAM, which is used to generate GIFT data using distillR. genome_annotations &lt;- read_tsv(&quot;data/genome_annotations.tsv.xz&quot;) %&gt;% rename(gene=1,genome=2) 2.2 Filter and normalise data Raw data needs to be filtered and normalised to make it useful for downstream analyses. 2.2.1 Generate coverage table By dividing the number of base hits by the length of each genome, coverage values can be calculated. genome_coverage &lt;- basehits %&gt;% mutate(across(where(is.numeric), ~ ./genome_metadata$length)) 2.2.2 Coverage filtering Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. min_coverage=0.3 read_counts_filt &lt;- genome_coverage %&gt;% mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% mutate(across(-1, ~ . * read_counts[[cur_column()]])) 2.2.3 Generate genome count table After filtering the low-coverage reads, read counts are transformed into genome counts using genome-length and read-length information. readlength=150 #change if sequencing read length is different genome_counts_filt &lt;- read_counts_filt %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength) )) genome_counts &lt;- read_counts %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength) )) 2.2.4 Distil functional annotations Raw functional annotations are distilled into genome-inferred functional traits to generate biologically more meaningful functional traits for downstream analyses. genome_gifts &lt;- distill(genome_annotations,GIFT_db,genomecol=2,annotcol=c(9,10,19)) 2.3 Color scheme AlberdiLab projects use unified color schemes developed for the Earth Hologenome Initiative, to facilitate figure interpretation. phylum_colors &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;) %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% pull(colors, name=phylum) 2.4 Wrap working objects In the last step, the objects that are needed for downstream analyses are stored in an R object. save(read_counts, read_counts_filt, genome_counts, genome_counts_filt, genome_tree, genome_metadata, genome_gifts, sample_metadata, phylum_colors, file = &quot;data/data.Rdata&quot;) read_counts: Number of reads mapped to each genome in each sample. Note this is the unfiltered and unnormalised raw community composition table. genome_counts: Number of genomes quantified in each sample, calculated through filtering and normalising read_counts. This is the community composition table to be used in downstream analyses unless otherwise stated. genome_tree: Phylogenetic tree of the genomes, to be employed in downstream phylogenetic analyses. genome_metadata: Taxonomic and quality information of the genomes. sample_metadata: Treatment/population and other relevant metadata of the samples. "],["data-quality.html", "Chapter 3 Data quality 3.1 Load statistics 3.2 Individual overview 3.3 Biplots 3.4 Quality flagging", " Chapter 3 Data quality load(&quot;data/data.Rdata&quot;) 3.1 Load statistics read_stats &lt;- read_tsv(&quot;data/reports/reads_multiqc_general_stats.txt&quot;, col_types = cols_only(&quot;Sample&quot; = col_character(), &quot;FastQC_mqc-generalstats-fastqc-total_sequences&quot; = col_double(), &quot;FastQC_mqc-generalstats-fastqc-percent_gc&quot; = col_double(), &quot;FastQC_mqc-generalstats-fastqc-percent_duplicates&quot; = col_double())) %&gt;% mutate(Sample = str_extract(Sample, &quot;M\\\\d+&quot;)) %&gt;% rename(microsample=Sample, total_sequences=&quot;FastQC_mqc-generalstats-fastqc-total_sequences&quot;, percent_gc=&quot;FastQC_mqc-generalstats-fastqc-percent_gc&quot;, percent_dup=&quot;FastQC_mqc-generalstats-fastqc-percent_duplicates&quot;) %&gt;% group_by(microsample) %&gt;% summarise(total_sequences=sum(total_sequences), percent_unique=100-mean(percent_dup), percent_gc=mean(percent_gc)) host_mapping_stats &lt;- read_tsv(&quot;data/reports/preprocess_samtools-flagstat-dp_Percentage_of_total.txt&quot;) %&gt;% mutate(reference = case_when( grepl(&quot;GRCh38&quot;, Sample, ignore.case = TRUE) ~ &quot;human&quot;, grepl(&quot;GRCg7b&quot;, Sample, ignore.case = TRUE) ~ &quot;chicken&quot;, TRUE ~ NA )) %&gt;% filter(reference==&quot;chicken&quot;) %&gt;% mutate(Sample = str_extract(Sample, &quot;M\\\\d+&quot;)) %&gt;% rename(microsample=Sample,reads_mapped_host_percent=`Properly Paired`) %&gt;% select(microsample,reads_mapped_host_percent) %&gt;% group_by(microsample) %&gt;% summarise(reads_mapped_host_percent=mean(reads_mapped_host_percent)) human_mapping_stats &lt;- read_tsv(&quot;data/reports/preprocess_samtools-flagstat-dp_Percentage_of_total.txt&quot;) %&gt;% mutate(reference = case_when( grepl(&quot;GRCh38&quot;, Sample, ignore.case = TRUE) ~ &quot;human&quot;, grepl(&quot;GRCg7b&quot;, Sample, ignore.case = TRUE) ~ &quot;chicken&quot;, TRUE ~ NA )) %&gt;% filter(reference==&quot;human&quot;) %&gt;% mutate(Sample = str_extract(Sample, &quot;M\\\\d+&quot;)) %&gt;% rename(microsample=Sample,reads_mapped_human_percent=`Properly Paired`) %&gt;% select(microsample,reads_mapped_human_percent) %&gt;% group_by(microsample) %&gt;% summarise(reads_mapped_human_percent=mean(reads_mapped_human_percent)) quantification_stats &lt;- read_tsv(&quot;data/reports/quantify_multiqc_samtools_stats.txt&quot;) %&gt;% filter(str_detect(Sample, &quot;mgg-pbdrep&quot;)) %&gt;% mutate(Sample = str_extract(Sample, &quot;M\\\\d+&quot;)) %&gt;% rename(microsample=Sample) %&gt;% group_by(microsample) %&gt;% summarise(reads_mapped=sum(reads_mapped),reads_mapped_percent=mean(reads_mapped_percent)) quality_stats &lt;- read_stats %&gt;% left_join(host_mapping_stats, by=join_by(microsample==microsample)) %&gt;% left_join(human_mapping_stats, by=join_by(microsample==microsample)) %&gt;% left_join(quantification_stats, by=join_by(microsample==microsample)) 3.2 Individual overview 3.2.1 Sequencing depth quality_stats %&gt;% left_join(sample_metadata,by=join_by(microsample==microsample)) %&gt;% mutate(animal=substr(cryosection,1,4)) %&gt;% ggplot(aes(x=total_sequences,y=microsample))+ geom_col()+ geom_vline(xintercept=10000000, linetype=&quot;dashed&quot;, color = &quot;red&quot;, size=1) + facet_nested(batch + section + type ~ ., scales=&quot;free&quot;, space=&quot;free&quot;, switch = &quot;y&quot;) + theme(strip.text.y.left = element_text(angle = 0)) + labs(x=&quot;Number of reads&quot;, y=&quot;Microsamples&quot;, fill=&quot;Library protocol&quot;) 3.2.2 Sequence duplication quality_stats %&gt;% left_join(sample_metadata,by=join_by(microsample==microsample)) %&gt;% mutate(animal=substr(cryosection,1,4)) %&gt;% ggplot(aes(x=percent_unique,y=microsample))+ geom_col()+ geom_vline(xintercept=35, linetype=&quot;dashed&quot;, color = &quot;red&quot;, size=1) + facet_nested(batch + section + type ~ ., scales=&quot;free&quot;, space=&quot;free&quot;, switch = &quot;y&quot;) + theme(strip.text.y.left = element_text(angle = 0)) + labs(x=&quot;Percentage of non-duplicates&quot;, y=&quot;Microsamples&quot;, fill=&quot;Collection success&quot;) 3.2.3 GC % quality_stats %&gt;% left_join(sample_metadata,by=join_by(microsample==microsample)) %&gt;% filter(section != &quot;Ileum&quot;) %&gt;% mutate(animal=substr(cryosection,1,4)) %&gt;% ggplot(aes(x=percent_gc,y=microsample))+ geom_col()+ geom_vline(xintercept=60, linetype=&quot;dashed&quot;, color = &quot;red&quot;, size=1) + facet_nested(batch + section + type ~ ., scales=&quot;free&quot;, space=&quot;free&quot;, switch = &quot;y&quot;) + theme(strip.text.y.left = element_text(angle = 0)) + labs(x=&quot;Percentage of GC&quot;, y=&quot;Microsamples&quot;, fill=&quot;Library protocol&quot;) 3.2.4 Host % quality_stats %&gt;% left_join(sample_metadata,by=join_by(microsample==microsample)) %&gt;% filter(section != &quot;Ileum&quot;) %&gt;% mutate(animal=substr(cryosection,1,4)) %&gt;% ggplot(aes(x=reads_mapped_host_percent,y=microsample))+ geom_col()+ facet_nested(batch + section + type ~ ., scales=&quot;free&quot;, space=&quot;free&quot;, switch = &quot;y&quot;) + theme(strip.text.y.left = element_text(angle = 0)) + labs(x=&quot;Host %&quot;, y=&quot;Microsamples&quot;, fill=&quot;Library protocol&quot;) 3.2.5 Human % quality_stats %&gt;% left_join(sample_metadata,by=join_by(microsample==microsample)) %&gt;% mutate(animal=substr(cryosection,1,4)) %&gt;% ggplot(aes(x=reads_mapped_human_percent,y=microsample))+ geom_col()+ geom_vline(xintercept=5, linetype=&quot;dashed&quot;, color = &quot;red&quot;, size=1) + facet_nested(batch + section + type ~ ., scales=&quot;free&quot;, space=&quot;free&quot;, switch = &quot;y&quot;) + theme(strip.text.y.left = element_text(angle = 0)) + labs(x=&quot;Human %&quot;, y=&quot;Microsamples&quot;, fill=&quot;Library protocol&quot;) 3.2.6 Bacteria mapping % quality_stats %&gt;% left_join(sample_metadata,by=&quot;microsample&quot;) %&gt;% mutate(animal=substr(cryosection,1,4)) %&gt;% ggplot(aes(x=reads_mapped_percent,y=microsample))+ geom_col()+ geom_vline(xintercept=75, linetype=&quot;dashed&quot;, color = &quot;red&quot;, size=1) + facet_nested(animal + type ~ ., scales=&quot;free&quot;, space=&quot;free&quot;, switch = &quot;y&quot;) + theme(strip.text.y.left = element_text(angle = 0)) + labs(x=&quot;Mapped to MAGs (%)&quot;, y=&quot;Microsamples&quot;, fill=&quot;Library protocol&quot;) 3.2.7 Domain-adjusted mapping rate 3.3 Biplots 3.3.1 Sequencing depth vs. GC % quality_stats %&gt;% left_join(sample_metadata,by=join_by(microsample==microsample)) %&gt;% filter(section != &quot;Ileum&quot;) %&gt;% filter(type == &quot;Positive&quot;) %&gt;% mutate(animal=substr(cryosection,1,4)) %&gt;% ggplot(aes(x=percent_gc,y=total_sequences))+ geom_point()+ facet_nested(. ~ batch, scales=&quot;free&quot;) + labs(color=&quot;Sexrion&quot;) 3.3.2 Unique sequences vs. GC % quality_stats %&gt;% left_join(sample_metadata,by=join_by(microsample==microsample)) %&gt;% filter(section != &quot;Ileum&quot;) %&gt;% filter(type == &quot;Positive&quot;) %&gt;% mutate(animal=substr(cryosection,1,4)) %&gt;% ggplot(aes(x=percent_gc,y=percent_unique))+ geom_point()+ facet_nested(. ~ batch, scales=&quot;free&quot;)+ labs(color=&quot;Library protocol&quot;) 3.4 Quality flagging quality &lt;- quality_stats %&gt;% mutate(depth = case_when( total_sequences &lt;= 10000000 ~ 0, total_sequences &gt; 10000000 ~ 1, TRUE ~ NA)) %&gt;% mutate(duplicates = case_when( percent_unique &lt;= 35 ~ 0, percent_unique &gt; 35 ~ 1, TRUE ~ NA)) %&gt;% mutate(gc = case_when( percent_gc &gt;= 60 ~ 0, percent_gc &lt; 60 ~ 1, TRUE ~ NA)) %&gt;% mutate(human = case_when( reads_mapped_human_percent &gt;= 5 ~ 0, reads_mapped_human_percent &lt; 5 ~ 1, TRUE ~ NA)) %&gt;% mutate(bacteria = case_when( reads_mapped_percent &lt;= 75 ~ 0, reads_mapped_percent &gt; 75 ~ 1, TRUE ~ NA)) %&gt;% select(microsample, depth, duplicates, gc, human, bacteria) %&gt;% mutate(quality = depth + duplicates + gc + human + bacteria) %&gt;% select(microsample, quality) quality %&gt;% write_tsv(&quot;results/quality.tsv&quot;) 3.4.1 Quality overview quality %&gt;% left_join(sample_metadata,by=join_by(microsample==microsample)) %&gt;% filter(section != &quot;Ileum&quot;) %&gt;% mutate(animal=substr(cryosection,1,4)) %&gt;% ggplot(aes(x=quality,y=microsample))+ geom_col()+ geom_vline(xintercept=5, linetype=&quot;dashed&quot;, color = &quot;red&quot;, size=1) + facet_nested(batch + section + type ~ ., scales=&quot;free&quot;, space=&quot;free&quot;, switch = &quot;y&quot;) + theme(strip.text.y.left = element_text(angle = 0)) + labs(x=&quot;Quality score&quot;, y=&quot;Microsamples&quot;, fill=&quot;Microsample area&quot;) quality %&gt;% left_join(sample_metadata,by=join_by(microsample==microsample)) %&gt;% filter(section != &quot;Ileum&quot;) %&gt;% filter(type == &quot;Positive&quot;) %&gt;% group_by(section) %&gt;% summarise(average=mean(quality, na.rm=TRUE), percentage_5 = mean(quality == 5, na.rm = TRUE) * 100) %&gt;% tt() tinytable_qajq4gf8nvjlc4pvziob .table td.tinytable_css_gdniho4hkem9qfu798qi, .table th.tinytable_css_gdniho4hkem9qfu798qi { border-bottom: solid 0.1em #d3d8dc; } section average percentage_5 Caecum right 4.166667 53.33333 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
